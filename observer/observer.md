观察者模式（ Observer Pattern） 也叫做发布订阅模式（ Publish/subscribe） ,它是一个在项目中经常使用的模式， 其定义如下：

Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.

定义对象间一种一对多的依赖关系， 使得每当一个对象改变状态， 则所有依赖于它的对象都会得到通知并被自动更新。

---

## 观察者模式的几个角色名称

* Subject被观察者
定义被观察者必须实现的职责， 它必须能够动态地增加、 取消观察者。 它一般是抽象类
或者是实现类， 仅仅完成作为被观察者必须实现的职责： 管理观察者并通知观察者。

* Observer观察者
观察者接收到消息后， 即进行update（ 更新方法） 操作， 对接收到的信息进行处理。

* ConcreteSubject具体的被观察者
定义被观察者自己的业务逻辑， 同时定义对哪些事件进行通知。

* ConcreteObserver具体的观察者
每个观察在接收到消息后的处理反应是不同， 各个观察者有自己的处理逻辑。

----

## 观察者模式的优点

* 观察者和被观察者之间是抽象耦合
  如此设计， 则不管是增加观察者还是被观察者都非常容易扩展， 而且在Java中都已经实
现的抽象层级的定义， 在系统扩展方面更是得心应手。

* 建立一套触发机制
  根据单一职责原则， 每个类的职责是单一的， 那么怎么把各个单一的职责串联成真实世
界的复杂的逻辑关系呢？ 比如， 我们去打猎， 打死了一只母鹿， 母鹿有三个幼崽， 因失去了母鹿而饿死， 尸体又被两只秃鹰争抢， 因分配不均， 秃鹰开始斗殴， 然后羸弱的秃鹰死掉，生存下来的秃鹰， 则因此扩大了地盘……这就是一个触发机制， 形成了一个触发链。 观察者模式可以完美地实现这里的链条形式。

---
## 观察者模式的缺点

观察者模式需要考虑一下开发效率和运行效率问题， 一个被观察者， 多个观察者， 开发
和调试就会比较复杂， 而且在Java中消息的通知默认是顺序执行， 一个观察者卡壳， 会影响整体的执行效率。 在这种情况下， 一般考虑采用异步的方式。

多级触发时的效率更是让人担忧， 大家在设计时注意考虑。

---

## 观察者模式的使用场景

* 关联行为场景。 需要注意的是， 关联行为是可拆分的， 而不是“组合”关系。

* 事件多级触发场景。

* 跨系统的消息交换场景， 如消息队列的处理机制。

---

注意 它和责任链模式的最大区别就是观察者广播链在传播的过程中消息是随时更改
的， 它是由相邻的两个节点协商的消息结构； 而责任链模式在消息传递过程中基本上保持消息不可变， 如果要改变， 也只是在原有的消息上进行修正。


异步处理问题
这个EJB是一个非常好的例子， 被观察者发生动作了， 观察者要做出回应， 如果观察者
比较多， 而且处理时间比较长怎么办？ 那就用异步呗， 异步处理就要考虑线程安全和队列的问题， 这个大家有时间看看Message Queue， 就会有更深的了解。

---

## 观察者模式在实际项目和生活中非常常见， 我们举几个经常发生的例子来说明。

###文件系统
比如， 在一个目录下新建立一个文件， 这个动作会同时通知目录管理器增加该目录， 并
通知磁盘管理器减少1KB的空间， 也就说“文件”是一个被观察者， “目录管理器”和“磁盘管理器”则是观察者。

###猫鼠游戏
夜里猫叫一声， 家里的老鼠撒腿就跑， 同时也吵醒了熟睡的主人， 这个场景中， “猫”就
是被观察者， 老鼠和人则是观察者。

### ATM取钱
比如你到ATM机器上取钱， 多次输错密码， 卡就会被ATM吞掉， 吞卡动作发生的时
候， 会触发哪些事件呢？ 第一， 摄像头连续快拍， 第二， 通知监控系统， 吞卡发生； 第三，初始化ATM机屏幕， 返回最初状态。 一般前两个动作都是通过观察者模式来完成的， 后一个动作是异常来完成。

### 广播收音机
电台在广播， 你可以打开一个收音机， 或者两个收音机来收听， 电台就是被观察者， 收
音机就是观察者。
